// +build ignore

package main

import (
	"log"
	"os"
	"strings"
	"text/template"
	"time"
)

var types = []string{
	"bool",
	"uint", "uint8", "byte", "uint16", "uint32", "uint64",
	"int", "int8", "int16", "int32", "rune", "int64",
	"float32", "float64",
	"complex64", "complex128",
	"string",
}

var tmpl = template.Must(template.New("").Parse(`// Code generated by result_gen.go; DO NOT EDIT.
// This file was generated by robots at
// {{.Timestamp}}
package forcer

type Result []interface{}

func (r Result) Get(i int) interface{} {
	return r[i]
}

{{- $typeMethods := .TypeMethods}}
{{- range $typeName, $methodName := $typeMethods}}

func (r Result) {{$methodName}}(i int) {{$typeName}} {
	return r[i].({{$typeName}})
}

func (r Result) {{$methodName}}Ptr(i int) *{{$typeName}} {
	return r[i].(*{{$typeName}})
}

func (r Result) {{$methodName}}s(i int) []{{$typeName}} {
	return r[i].([]{{$typeName}})
}

{{- range $valueTypeName, $valueMethodName := $typeMethods}}

func (r Result) Map{{$methodName}}{{$valueMethodName}}(i int) map[{{$typeName}}]{{$valueTypeName}} {
	return r[i].(map[{{$typeName}}]{{$valueTypeName}})
}
{{- end}}
{{- end}}
`))

func main() {
	typeMethods := map[string]string{"interface{}": "Interface"}
	for _, t := range types {
		typeMethods[t] = strings.Title(t)
	}

	f, err := os.Create("result.go")
	if err != nil {
		log.Panic(err)
	}
	defer f.Close()

	err = tmpl.Execute(f, struct {
		Timestamp   string
		TypeMethods map[string]string
	}{
		Timestamp:   time.Now().String(),
		TypeMethods: typeMethods,
	})
	if err != nil {
		log.Panic(err)
	}
}
